---
phase: 03-frontend-and-seo
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - app/(marketing)/blog/page.tsx
  - app/(marketing)/blog/[slug]/page.tsx
  - app/sitemap.ts
  - app/robots.ts
autonomous: true

must_haves:
  truths:
    - "Visiting /blog shows a paginated list of published posts — drafts and noIndex posts are not visible"
    - "Visiting /blog/[slug] renders the full post with rich text body, author name/bio/avatar, and correct Article or HowTo JSON-LD in the page source"
    - "Visiting /blog/[slug] for a tutorial post outputs HowTo JSON-LD with steps array instead of Article"
    - "/sitemap.xml includes all published, non-noIndex blog posts and KB articles with correct URLs"
    - "/robots.txt blocks /admin from crawling and links to /sitemap.xml"
    - "Blog listing page has working pagination controls (next/previous)"
    - "Each blog post page has proper generateMetadata with title, description, OG tags, and canonical URL from plugin-seo fields"
  artifacts:
    - path: "app/(marketing)/blog/page.tsx"
      provides: "Blog listing with pagination"
      min_lines: 40
    - path: "app/(marketing)/blog/[slug]/page.tsx"
      provides: "Individual blog post with RichText rendering, author bio, JSON-LD"
      min_lines: 60
    - path: "app/sitemap.ts"
      provides: "XML sitemap with unstable_cache and tag-based revalidation"
      exports: ["default"]
    - path: "app/robots.ts"
      provides: "robots.txt blocking /admin"
      exports: ["default"]
  key_links:
    - from: "app/(marketing)/blog/page.tsx"
      to: "payload.find({ collection: 'posts' })"
      via: "getPayload local API"
      pattern: "payload\\.find.*collection.*posts"
    - from: "app/(marketing)/blog/[slug]/page.tsx"
      to: "@payloadcms/richtext-lexical/react"
      via: "RichText component import"
      pattern: "import.*RichText.*richtext-lexical/react"
    - from: "app/(marketing)/blog/[slug]/page.tsx"
      to: "application/ld+json"
      via: "inline script tag"
      pattern: "application/ld\\+json"
    - from: "app/sitemap.ts"
      to: "src/lib/cache-tags.ts"
      via: "import CACHE_TAGS for unstable_cache tags"
      pattern: "import.*CACHE_TAGS.*cache-tags"
---

<objective>
Build the blog listing page (/blog), individual blog post page (/blog/[slug]) with rich text rendering, author bio, and Article/HowTo JSON-LD structured data, plus the XML sitemap and robots.txt.

Purpose: Delivers the public-facing blog experience (BLOG-06, BLOG-07, BLOG-08), Article and HowTo structured data for search engines (SEO-06, SEO-07), the XML sitemap (SEO-04), and robots.txt (SEO-05). These are the primary SEO entry points for organic traffic.

Output: Four new files — blog listing page, blog post page, sitemap.ts, robots.ts — all as Server Components using Payload Local API.
</objective>

<execution_context>
@/Users/alexander/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexander/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-frontend-and-seo/03-RESEARCH.md
@.planning/phases/03-frontend-and-seo/03-01-SUMMARY.md

# Existing layout (pages render inside this)
@app/(marketing)/layout.tsx

# Collections (for understanding the data shape)
@src/collections/Posts.ts
@src/collections/Authors.ts

# Generated types (for TypeScript imports)
@payload-types.ts

# Cache tags (shared with revalidation hooks from 03-01)
@src/lib/cache-tags.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Blog listing page with pagination</name>
  <files>app/(marketing)/blog/page.tsx</files>
  <action>
    Create `app/(marketing)/blog/page.tsx` as a Server Component.

    **Data fetching:**
    - Import `configPromise` from `@payload-config` and `getPayload` from `payload`
    - Accept `searchParams` prop: `{ searchParams: Promise<{ page?: string }> }`
    - Parse `page` param, default to 1
    - Call `payload.find()` on `posts` collection:
      - `depth: 1` (populate author and featuredImage)
      - `limit: 10` (10 posts per page)
      - `page: currentPage`
      - `overrideAccess: false` (respect access control — only published posts)
      - `where: { _status: { equals: 'published' } }` (belt-and-suspenders with access control)
      - `select: { title: true, slug: true, excerpt: true, featuredImage: true, publishedAt: true, author: true }` (only fields needed for listing)
      - `sort: '-publishedAt'` (newest first)

    **Rendering:**
    - Page title: "Blog | PackBee"
    - Map over `posts.docs` to render a card for each post:
      - Post title as `<h2>` linked to `/blog/${post.slug}`
      - Excerpt text (if exists)
      - Author name (resolve from populated relationship: `typeof post.author === 'object' ? post.author.name : ''`)
      - Published date formatted with `new Date(post.publishedAt).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })`
      - Featured image (if exists): `<img>` with `post.featuredImage.url` and `post.featuredImage.alt`
    - Pagination controls at bottom:
      - "Previous" link to `/blog?page=${currentPage - 1}` (hidden when on page 1)
      - "Next" link to `/blog?page=${currentPage + 1}` (hidden when on last page)
      - Use `posts.totalPages` and `posts.page` for logic
    - Empty state: "No posts yet." when `posts.docs.length === 0`

    **Metadata:**
    - Export `generateMetadata` returning:
      ```typescript
      export const metadata: Metadata = {
        title: 'Blog | PackBee',
        description: 'Tips, tutorials, and insights about e-commerce fulfillment, pick-and-pack verification, and shipping optimization.',
      }
      ```

    **Styling:** Use basic Tailwind classes for layout — no elaborate design. Use `max-w-4xl mx-auto px-4 py-8` container. Cards with `border-b py-6`. This is intentionally minimal — design phase is deferred per PROJECT.md.
  </action>
  <verify>
    1. File exists at `app/(marketing)/blog/page.tsx`
    2. `grep 'overrideAccess: false' app/(marketing)/blog/page.tsx` matches
    3. `grep 'pagination' app/(marketing)/blog/page.tsx` matches (pagination controls exist)
    4. `grep 'posts' app/(marketing)/blog/page.tsx | grep 'find'` matches (data fetching)
  </verify>
  <done>Blog listing page renders published posts with pagination, author names, dates, and excerpts. Drafts and unpublished posts are excluded via overrideAccess: false.</done>
</task>

<task type="auto">
  <name>Task 2: Blog post page with rich text, author bio, and JSON-LD</name>
  <files>app/(marketing)/blog/[slug]/page.tsx</files>
  <action>
    Create `app/(marketing)/blog/[slug]/page.tsx` as a Server Component.

    **Data fetching:**
    - Import `configPromise` from `@payload-config`, `getPayload` from `payload`, `RichText` from `@payloadcms/richtext-lexical/react`, `notFound` from `next/navigation`, `cache` from `react`
    - Create a `queryPostBySlug` function wrapped in `React.cache()`:
      ```typescript
      const queryPostBySlug = cache(async ({ slug }: { slug: string }) => {
        const payload = await getPayload({ config: configPromise })
        const result = await payload.find({
          collection: 'posts',
          depth: 1,
          limit: 1,
          overrideAccess: false,
          pagination: false,
          where: { slug: { equals: slug } },
        })
        return result.docs?.[0] || null
      })
      ```
    - In the page component, get slug from `params: Promise<{ slug: string }>`, query the post, call `notFound()` if not found

    **generateMetadata:**
    - Export async `generateMetadata` that calls `queryPostBySlug` and returns:
      - `title`: `post.meta?.title ?? post.title`
      - `description`: `post.meta?.description ?? post.excerpt ?? ''`
      - `robots`: `post.meta?.noIndex ? { index: false, follow: false } : undefined`
      - `alternates.canonical`: `post.meta?.canonicalURL ?? \`${process.env.NEXT_PUBLIC_SERVER_URL}/blog/${post.slug}\``
      - `openGraph`: title, description, images from `post.meta?.image`, type: 'article'

    **generateStaticParams:**
    - Export `generateStaticParams` that fetches all published post slugs for static generation:
      ```typescript
      export async function generateStaticParams() {
        const payload = await getPayload({ config: configPromise })
        const posts = await payload.find({
          collection: 'posts',
          draft: false,
          limit: 1000,
          overrideAccess: false,
          pagination: false,
          select: { slug: true },
        })
        return posts.docs.map(({ slug }) => ({ slug }))
      }
      ```

    **JSON-LD structured data:**
    - Build JSON-LD object based on `post.contentType`:
      - For `contentType === 'article'` (default): `@type: 'Article'` with headline, author, datePublished, dateModified, image, publisher (PackBee org)
      - For `contentType === 'tutorial'`: `@type: 'HowTo'` with name (=title), description (=excerpt), step array mapped from `post.steps`:
        ```typescript
        step: post.steps?.map((s, i) => ({
          '@type': 'HowToStep',
          position: i + 1,
          name: s.title,
          text: s.description,
        }))
        ```
    - Render as `<script type="application/ld+json" dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd).replace(/</g, '\\u003c') }} />`
    - Apply XSS mitigation: `.replace(/</g, '\\u003c')` on the JSON string

    **Author bio section:**
    - After the article body, render an author bio box IF `post.author` is populated (typeof === 'object'):
      - Author avatar (if exists): `<img>` with `post.author.avatar.url`
      - Author name as `<strong>`
      - Author role (if exists)
      - Author bio (if exists)

    **Article body:**
    - Use `<RichText data={post.body} />` from `@payloadcms/richtext-lexical/react`
    - Wrap in `<article>` with prose-like Tailwind classes: `prose prose-lg max-w-none` (or basic custom Tailwind if prose plugin not available)

    **Page structure:**
    ```
    <script type="application/ld+json" ... />
    <article className="max-w-4xl mx-auto px-4 py-8">
      <h1>{post.title}</h1>
      <div>{author name} · {date}</div>
      {featuredImage && <img ... />}
      <RichText data={post.body} />
      {/* Author bio section */}
    </article>
    ```

    **Styling:** Minimal Tailwind. Use `max-w-4xl mx-auto px-4 py-8` container. Design is deferred.
  </action>
  <verify>
    1. File exists at `app/(marketing)/blog/[slug]/page.tsx`
    2. `grep 'RichText' app/(marketing)/blog/[slug]/page.tsx` matches (rich text rendering)
    3. `grep 'application/ld+json' app/(marketing)/blog/[slug]/page.tsx` matches (JSON-LD present)
    4. `grep 'HowTo' app/(marketing)/blog/[slug]/page.tsx` matches (tutorial schema support)
    5. `grep 'author' app/(marketing)/blog/[slug]/page.tsx | head -5` shows author bio rendering
    6. `grep 'generateMetadata' app/(marketing)/blog/[slug]/page.tsx` matches
    7. `grep 'generateStaticParams' app/(marketing)/blog/[slug]/page.tsx` matches
  </verify>
  <done>Blog post page renders rich text content, displays author bio, outputs Article JSON-LD (or HowTo for tutorials), has proper generateMetadata with SEO fields, and generateStaticParams for static generation</done>
</task>

<task type="auto">
  <name>Task 3: Sitemap and robots.txt</name>
  <files>
    app/sitemap.ts
    app/robots.ts
  </files>
  <action>
    **IMPORTANT:** Both files go at `app/sitemap.ts` and `app/robots.ts` — at the app ROOT, NOT inside `(marketing)`. This is critical for correct URL serving at `/sitemap.xml` and `/robots.txt`.

    **1. Create app/sitemap.ts:**
    ```typescript
    import type { MetadataRoute } from 'next'
    import { unstable_cache } from 'next/cache'
    import { getPayload } from 'payload'
    import configPromise from '@payload-config'
    import { CACHE_TAGS } from '../src/lib/cache-tags'

    const getSitemapData = unstable_cache(
      async () => {
        const payload = await getPayload({ config: configPromise })
        const SITE_URL = process.env.NEXT_PUBLIC_SERVER_URL ?? ''

        const [posts, kbArticles] = await Promise.all([
          payload.find({
            collection: 'posts',
            overrideAccess: false,
            draft: false,
            limit: 1000,
            pagination: false,
            where: {
              and: [
                { _status: { equals: 'published' } },
                { 'meta.noIndex': { not_equals: true } },
              ],
            },
            select: { slug: true, updatedAt: true },
          }),
          payload.find({
            collection: 'knowledge-base',
            overrideAccess: false,
            draft: false,
            limit: 1000,
            pagination: false,
            where: {
              and: [
                { _status: { equals: 'published' } },
                { 'meta.noIndex': { not_equals: true } },
              ],
            },
            select: { slug: true, updatedAt: true },
          }),
        ])

        return [
          { url: `${SITE_URL}/`, lastModified: new Date().toISOString() },
          { url: `${SITE_URL}/blog`, lastModified: new Date().toISOString() },
          { url: `${SITE_URL}/help`, lastModified: new Date().toISOString() },
          ...posts.docs.map((p) => ({
            url: `${SITE_URL}/blog/${p.slug}`,
            lastModified: p.updatedAt,
          })),
          ...kbArticles.docs.map((k) => ({
            url: `${SITE_URL}/help/${k.slug}`,
            lastModified: k.updatedAt,
          })),
        ]
      },
      ['sitemap'],
      { tags: [CACHE_TAGS.POSTS_SITEMAP, CACHE_TAGS.KB_SITEMAP] },
    )

    export default async function sitemap(): Promise<MetadataRoute.Sitemap> {
      return getSitemapData()
    }
    ```

    Note: Import path for cache-tags uses `../src/lib/cache-tags` because `app/sitemap.ts` is at the app root. If this causes a TS path resolution issue, use the relative path that resolves correctly from `app/`.

    **2. Create app/robots.ts:**
    ```typescript
    import type { MetadataRoute } from 'next'

    export default function robots(): MetadataRoute.Robots {
      const SITE_URL = process.env.NEXT_PUBLIC_SERVER_URL ?? ''
      return {
        rules: [
          { userAgent: '*', allow: '/', disallow: ['/admin'] },
        ],
        sitemap: `${SITE_URL}/sitemap.xml`,
      }
    }
    ```

    **3. Verify import path resolves:**
    After creating both files, run:
    ```bash
    npx tsc --noEmit app/sitemap.ts app/robots.ts 2>&1 || true
    ```
    If the `../src/lib/cache-tags` import fails, adjust the relative path accordingly.
  </action>
  <verify>
    1. File exists at `app/sitemap.ts` (NOT inside (marketing))
    2. File exists at `app/robots.ts` (NOT inside (marketing))
    3. `grep 'CACHE_TAGS' app/sitemap.ts` matches (uses shared cache tags)
    4. `grep 'disallow.*admin' app/robots.ts` matches (blocks /admin)
    5. `grep 'sitemap.xml' app/robots.ts` matches (links to sitemap)
  </verify>
  <done>sitemap.xml serves all published, non-noIndex blog posts and KB articles with tag-based revalidation. robots.txt blocks /admin from crawlers and references the sitemap.</done>
</task>

</tasks>

<verification>
1. `app/(marketing)/blog/page.tsx` exists and fetches posts with `overrideAccess: false`
2. `app/(marketing)/blog/[slug]/page.tsx` exists with RichText rendering, author bio, Article/HowTo JSON-LD, generateMetadata, generateStaticParams
3. `app/sitemap.ts` exists at app root (not in route group) and uses CACHE_TAGS from shared constants
4. `app/robots.ts` exists at app root and blocks /admin
5. `next build` succeeds (or at minimum no TypeScript errors in the new files)
</verification>

<success_criteria>
- Blog listing at /blog shows published posts with pagination
- Blog post at /blog/[slug] renders rich text, author bio, and correct JSON-LD schema
- Sitemap includes all published non-noIndex content from both collections
- robots.txt blocks /admin and links to sitemap
- All pages use overrideAccess: false to prevent draft leakage
</success_criteria>

<output>
After completion, create `.planning/phases/03-frontend-and-seo/03-02-SUMMARY.md`
</output>

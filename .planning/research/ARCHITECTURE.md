# Architecture Patterns: Payload CMS 3.x in Next.js

**Domain:** Payload CMS embedded in existing Next.js 16 App Router landing page
**Researched:** 2026-02-18
**Confidence:** HIGH — verified against official Payload documentation, installation.mdx on GitHub, and the DeepWiki source which reflects the live Payload codebase.

---

## Recommended Architecture

Payload 3.x is Next.js-native: it lives inside your Next.js `/app` folder rather than running as a separate process. The entire integration rests on Next.js **route groups** (folders in parentheses that do not affect the URL), which let Payload's admin panel, API routes, and the existing landing page coexist without any routing conflicts or style leakage.

```
app/
├── (frontend)/           <-- existing landing page, renamed into its own route group
│   ├── layout.tsx        <-- current root layout moved here
│   └── page.tsx          <-- current home page moved here
│
└── (payload)/            <-- all Payload CMS infrastructure
    ├── layout.tsx        <-- auto-generated, wraps admin with Payload styles
    ├── custom.scss       <-- optional admin customization
    ├── admin/
    │   ├── [[...segments]]/
    │   │   └── page.tsx  <-- catch-all page: renders entire admin panel UI
    │   └── importMap.js  <-- auto-generated, maps custom components
    └── api/
        └── [...slug]/
            └── route.ts  <-- catch-all: handles all REST API endpoints

payload.config.ts          <-- Payload configuration (root of repo, next to /app)
src/collections/           <-- collection definitions (Posts, Authors, Media, etc.)
src/migrations/            <-- Drizzle migration files generated by Payload CLI
```

### Root-level files that change

| File | Change |
|------|--------|
| `next.config.ts` | Rename to `next.config.mjs` (ESM required), wrap with `withPayload()` |
| `tsconfig.json` | Add `"@payload-config": ["./payload.config.ts"]` to paths |
| `package.json` | Add `"type": "module"` or use `.mjs` config extension |

---

## Component Boundaries

| Component | Responsibility | Communicates With |
|-----------|---------------|-------------------|
| `payload.config.ts` | Single source of truth: defines collections, database adapter, plugins, media, auth | Payload core, database adapter, Next.js via `withPayload()` |
| `(payload)/admin/[[...segments]]/page.tsx` | Renders the full Payload Admin UI as React Server Components | Payload Local API directly (no HTTP) |
| `(payload)/api/[...slug]/route.ts` | Handles REST API requests (`/api/posts`, `/api/media`, etc.) | Payload core operations layer |
| `(payload)/layout.tsx` | Scopes Payload admin styles; imports `@payloadcms/next/css` | Admin catch-all pages only |
| `(frontend)/layout.tsx` | Your existing root layout (fonts, global CSS) | Frontend pages only |
| `(frontend)/page.tsx` | Existing landing page | No Payload dependency needed |
| `app/(frontend)/blog/[slug]/page.tsx` | Blog post render (to be built) | Payload Local API via `getPayload()` |
| `app/(frontend)/blog/page.tsx` | Blog listing (to be built) | Payload Local API via `getPayload()` |
| `app/(frontend)/kb/[slug]/page.tsx` | Knowledge base article (to be built) | Payload Local API via `getPayload()` |
| `src/collections/` | TypeScript definitions for Posts, Authors, Categories, Tags, Media, KBArticles, Users | payload.config.ts imports these |
| `src/migrations/` | Drizzle SQL migration files (version-controlled) | PostgreSQL via Drizzle ORM |

---

## Data Flow

### Admin Panel Write Path

```
Author (browser)
    |
    v
/admin/* (Next.js catch-all page)
    |
    v
Payload Admin UI (React Server Components)
    |
    v  [Local API — no HTTP round-trip]
payload.find() / payload.create() / payload.update()
    |
    v
Drizzle ORM (postgresAdapter)
    |
    v
Supabase PostgreSQL (dedicated CMS instance)
```

### Frontend Read Path (Blog/KB pages)

```
Visitor (browser)
    |
    v
Next.js App Router: /blog/[slug]/page.tsx (Server Component)
    |
    v  [Local API — direct DB access, no HTTP]
const payload = await getPayload({ config })
await payload.find({ collection: 'posts', where: { slug: { equals: slug } } })
    |
    v
Supabase PostgreSQL
    |
    v
React renders HTML + sends to browser (ISR/SSG possible)
```

### REST API Path (if needed for external consumers)

```
External client
    |
    v  HTTP GET /api/posts?where[status][equals]=published
(payload)/api/[...slug]/route.ts
    |
    v
Payload operations layer (same as Local API, just via HTTP)
    |
    v
Supabase PostgreSQL
```

The Local API is the primary data access pattern for frontend pages. It has zero HTTP overhead because it calls the database directly on the server. REST API exists automatically but is secondary for this project.

---

## How Existing Landing Page Coexists with CMS Routes

The critical mechanism is the **route group rename**. Currently the app has:

```
app/
├── layout.tsx   <-- root layout
└── page.tsx     <-- home page (/)
```

After integration, this becomes:

```
app/
├── (frontend)/
│   ├── layout.tsx   <-- same root layout, now scoped to frontend routes
│   └── page.tsx     <-- same home page, URL stays /
└── (payload)/
    └── ...          <-- Payload routes, URL prefix /admin and /api
```

Route groups are transparent to the URL — `(frontend)/page.tsx` still serves `/`. The `(payload)/layout.tsx` imports Payload-specific CSS (`@payloadcms/next/css`) without polluting the landing page layout. GSAP and Framer Motion in the landing page are unaffected because they live in the `(frontend)` route group with its own isolated layout.

**URL namespace summary:**

| URL pattern | Handled by |
|-------------|-----------|
| `/` | `(frontend)/page.tsx` — landing page, unchanged |
| `/blog` | `(frontend)/blog/page.tsx` — to be built |
| `/blog/[slug]` | `(frontend)/blog/[slug]/page.tsx` — to be built |
| `/kb` | `(frontend)/kb/page.tsx` — to be built |
| `/kb/[slug]` | `(frontend)/kb/[slug]/page.tsx` — to be built |
| `/admin/*` | `(payload)/admin/[[...segments]]/page.tsx` — Payload Admin |
| `/api/*` | `(payload)/api/[...slug]/route.ts` — Payload REST API |

---

## Admin Panel Setup

The admin panel is accessed at `/admin`. On first boot, Payload creates the first admin user interactively. Subsequent users can be invited through the Users collection.

Key configuration in `payload.config.ts`:

```typescript
import { buildConfig } from 'payload'
import { postgresAdapter } from '@payloadcms/db-postgres'
import { lexicalEditor } from '@payloadcms/richtext-lexical'
import { seoPlugin } from '@payloadcms/plugin-seo'
import sharp from 'sharp'

export default buildConfig({
  admin: {
    user: 'users',          // slug of the auth-enabled collection
  },
  collections: [
    // imported from src/collections/
    Users, Posts, Authors, Categories, Tags, Media, KBArticles,
  ],
  editor: lexicalEditor(),
  db: postgresAdapter({
    pool: {
      connectionString: process.env.DATABASE_URL,
      ssl: { rejectUnauthorized: false },   // required for Supabase
    },
    push: false,             // IMPORTANT: disable auto-push; use migrations instead
    migrationDir: './src/migrations',
  }),
  upload: {
    // local filesystem: stores files in public/media, serves at /media/*
    limits: { fileSize: 5000000 },  // 5MB
  },
  plugins: [seoPlugin({ /* ... */ })],
  secret: process.env.PAYLOAD_SECRET || '',
  sharp,
})
```

The admin panel renders entirely as React Server Components. The first page load fetches data via the Local API server-side; no separate API call is made from the browser to hydrate initial content.

---

## Database Layer

Payload uses **Drizzle ORM** under the hood when using the PostgreSQL adapter. It generates and manages the schema automatically from your collection definitions.

### Development vs Production modes

| Mode | Config | Behavior |
|------|--------|----------|
| `push: true` (default) | Development | Schema changes auto-applied on next `next dev` start. No migration files. Dangerous if used against shared DB. |
| `push: false` (recommended) | Both | Explicit migration files created with `npx payload migrate:create`. Applied with `npx payload migrate`. |

**Production workflow:**

```bash
# 1. Schema changes (local dev)
npx payload migrate:create --name add_tags_to_posts

# 2. Migration file committed to git
git add src/migrations/

# 3. Production deploy: run migrations before starting server
npx payload migrate
```

Payload can also run migrations automatically on initialization via `prodMigrations` in the adapter config — suitable for long-running servers (Coolify/Hetzner), but note it slows first boot.

---

## Media Storage

With local filesystem storage:

```typescript
// In the Media collection definition
export const Media: CollectionConfig = {
  slug: 'media',
  upload: {
    staticDir: './public/media',    // files stored here on disk
    staticURL: '/media',            // served at this URL by Next.js
    imageSizes: [
      { name: 'thumbnail', width: 400, height: 300 },
      { name: 'card', width: 768, height: 500 },
      { name: 'tablet', width: 1024, height: null },
    ],
    mimeTypes: ['image/*'],
  },
  fields: [{ name: 'alt', type: 'text', required: true }],
}
```

**Docker/Coolify:** The `/app/public/media` directory (inside the container) must be mounted as a persistent volume. Without this, uploaded media is lost on container restarts.

```
Coolify volume mount:
  Source: (named volume, e.g. packbee-cms-media)
  Destination: /app/public/media
```

---

## Rich Text Rendering

Payload's editor is Lexical (marked stable in 3.0). Content is stored as JSON. Two rendering strategies:

1. **`<RichText>` component from `@payloadcms/richtext-lexical/react`** — direct JSX rendering on the server, supports custom block components.
2. **HTML converter** — `convertLexicalToHTML()` — generates HTML string, useful for RSS feeds or static output.

Recommended approach for Next.js Server Components:

```typescript
import { RichText } from '@payloadcms/richtext-lexical/react'

export default async function PostPage({ params }) {
  const payload = await getPayload({ config })
  const post = await payload.findByID({ collection: 'posts', id: params.id })
  return <RichText data={post.content} />
}
```

---

## SEO Integration

The `@payloadcms/plugin-seo` plugin injects a `meta` field group (title, description, image) into any collection. In Next.js, you use this data to populate `generateMetadata()`:

```typescript
export async function generateMetadata({ params }): Promise<Metadata> {
  const payload = await getPayload({ config })
  const post = await payload.find({
    collection: 'posts',
    where: { slug: { equals: params.slug } },
  })
  const { meta } = post.docs[0]
  return {
    title: meta?.title,
    description: meta?.description,
    openGraph: { images: [meta?.image?.url] },
  }
}
```

Sitemap: Use Next.js `app/sitemap.ts` (returns `MetadataRoute.Sitemap`), which queries Payload Local API to enumerate all published posts and KB articles. This integrates seamlessly with existing Next.js sitemap conventions.

---

## Authentication and Access Control

Payload's built-in auth manages admin users. For this project (small internal team):

- A `users` collection with `auth: true` handles admin login
- No public-facing auth is needed (blog is read-only for visitors)
- Access control on collections: `read: () => true` for published posts; `create/update/delete` restricted to authenticated admins

```typescript
export const Posts: CollectionConfig = {
  slug: 'posts',
  access: {
    read: ({ req }) => {
      // Public can read published posts; admins can read all
      if (req.user) return true
      return { status: { equals: 'published' } }
    },
    create: isAdmin,
    update: isAdmin,
    delete: isAdmin,
  },
  // ...
}
```

---

## Build Order (What Depends on What)

The dependency graph for implementation:

```
1. Infrastructure Setup (no dependencies)
   - Install Payload packages
   - Rename next.config.ts → next.config.mjs, add withPayload()
   - Update tsconfig.json with @payload-config path alias
   - Create payload.config.ts (minimal, with postgresAdapter)
   - Copy (payload) route group files from blank template
   - Move existing app/* into (frontend)/ route group
   - Verify landing page still works

2. Database Layer (depends on: 1)
   - Configure postgresAdapter with Supabase connection string
   - First boot creates DB schema via push (dev only)
   - Switch to push: false and create initial migration

3. Users Collection (depends on: 2)
   - Define users collection with auth: true
   - Create first admin user at /admin

4. Core Content Collections (depends on: 3)
   - Authors collection
   - Categories and Tags collections
   - Media collection (with upload config)

5. Blog Post Collection (depends on: 4)
   - Posts collection with relationships to Authors, Categories, Tags, Media
   - SEO plugin applied to Posts
   - Lexical editor for body content

6. Knowledge Base Collection (depends on: 4)
   - KBArticles collection (similar to Posts, different taxonomy)
   - SEO plugin applied to KBArticles

7. Frontend Blog Routes (depends on: 5)
   - /blog listing page (pagination, category filter)
   - /blog/[slug] post page (Lexical render, SEO metadata)
   - sitemap.ts covering posts

8. Frontend KB Routes (depends on: 6)
   - /kb listing page
   - /kb/[slug] article page
   - sitemap.ts updated to cover KB articles

9. Production Hardening (depends on: 1-8)
   - Switch push: false, create migration workflow
   - Dockerfile update: standalone output, volume mount for /public/media
   - Coolify persistent volume configuration
   - Environment variable audit
```

Collections 5 and 6 (Posts vs KBArticles) can be built in parallel once step 4 is done. Frontend routes (7, 8) require their respective collection (5, 6) to exist.

---

## Anti-Patterns to Avoid

### Anti-Pattern 1: Not moving existing app files into a route group
**What:** Leaving `app/layout.tsx` at the root alongside `(payload)/layout.tsx`.
**Why bad:** Two root layouts conflict. Payload's CSS bleeds into the landing page.
**Instead:** Move all existing app files into `app/(frontend)/` before installing Payload.

### Anti-Pattern 2: Using `push: true` against the shared Supabase instance
**What:** Leaving the default `push: true` in postgresAdapter when multiple devs share the DB.
**Why bad:** Any local schema change immediately mutates the shared database, potentially dropping columns.
**Instead:** Each dev uses their own local DB or dedicated Supabase project for development. Use `push: false` + migrations in all shared environments.

### Anti-Pattern 3: Fetching Payload data via REST API from Server Components
**What:** Using `fetch('/api/posts')` inside Next.js Server Components.
**Why bad:** Adds unnecessary HTTP round-trip; Local API is available directly on the server.
**Instead:** Use `getPayload({ config })` then `payload.find()` in Server Components.

### Anti-Pattern 4: Storing media in Next.js public folder without Docker volume
**What:** Configuring `staticDir: './public/media'` but not mounting a persistent volume in Docker.
**Why bad:** Container restarts (deployments) wipe uploaded media files.
**Instead:** Mount `/app/public/media` as a named Docker volume in Coolify before ever uploading files.

### Anti-Pattern 5: Using `next.config.ts` (TypeScript) with Payload
**What:** Keeping `next.config.ts` when adding Payload.
**Why bad:** Payload requires ESM; `withPayload()` is an ES module. TypeScript config files don't support top-level `import` from ESM packages without additional tooling.
**Instead:** Rename to `next.config.mjs` and use ES module syntax.

---

## Sources

- [Installation | Payload Documentation (GitHub source)](https://github.com/payloadcms/payload/blob/main/docs/getting-started/installation.mdx) — HIGH confidence (official docs repo)
- [DeepWiki: payloadcms/payload](https://deepwiki.com/payloadcms/payload) — HIGH confidence (reflects live codebase)
- [Payload 3.0 Template (payload)/layout.tsx](https://github.com/payloadcms/payload/blob/main/templates/website/src/app/%28payload%29/layout.tsx) — HIGH confidence (official template)
- [Payload CMS 3.0 Next.js integration blog post](https://payloadcms.com/posts/blog/payload-30-the-first-cms-that-installs-directly-into-any-nextjs-app) — HIGH confidence (official Payload blog)
- [The Ultimate Guide To Using Next.js with Payload](https://payloadcms.com/posts/blog/the-ultimate-guide-to-using-nextjs-with-payload) — HIGH confidence (official guide)
- [Payload PostgreSQL Migrations (ryanschiang.com)](https://ryanschiang.com/payload-cms-postgres-migrations) — MEDIUM confidence (community, verified against official migration docs)
- [How to Run Payload CMS in Docker (sliplane.io)](https://sliplane.io/blog/how-to-run-payload-cms-in-docker) — MEDIUM confidence (community, consistent with official deployment docs)
- [Payload community: Adding Payload to existing project](https://payloadcms.com/community-help/discord/adding-payload-to-an-existing-project) — MEDIUM confidence (official community help)
- [SEO Plugin npm package](https://www.npmjs.com/package/@payloadcms/plugin-seo) — HIGH confidence (official npm package)
- [Sitemap guide: payloadcms.com](https://payloadcms.com/posts/guides/how-to-build-an-seo-friendly-sitemap-in-payload--nextjs) — HIGH confidence (official guide)
- [Structured data guide: payloadcms.com](https://payloadcms.com/posts/guides/add-schema-markup-to-payload--nextjs-for-better-seo) — HIGH confidence (official guide)
- [Coolify persistent storage discussion](https://payloadcms.com/community-help/discord/installing-payloadcms-v3-on-coolify-with-dockerfile-guide) — MEDIUM confidence (community verified against Coolify docs)
